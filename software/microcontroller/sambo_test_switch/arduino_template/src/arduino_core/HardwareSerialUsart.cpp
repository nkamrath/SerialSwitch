/**
 * \file HardwareSerialUsart.h
 *
 * \brief USART peripheral library for SAMBO platforms
 *
 * Copyright (c) 2016 Nate Kamrath. All rights reserved.
 *
 * \sambo_license_start
 *
 * \page "SAMBO License"
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL AUTHORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \sambo_license_stop
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include "Arduino.h"

#include "HardwareSerialUsart.h"


// SerialEvent functions are weak, so when the user doesn't define them,
// the linker just sets their address to 0 (which is checked below).
// The Serialx_available is just a wrapper around Serialx.available(),
// but we can refer to it weakly so we don't pull in the entire
// HardwareSerial instance if the user doesn't also refer to it.
#if defined(HAVE_HWSERIAL0)
  void serialEvent() __attribute__((weak));
  bool Serial0_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL1)
  void serialEvent1() __attribute__((weak));
  bool Serial1_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL2)
  void serialEvent2() __attribute__((weak));
  bool Serial2_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL3)
  void serialEvent3() __attribute__((weak));
  bool Serial3_available() __attribute__((weak));
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
#endif
#if defined(HAVE_HWSERIAL1)
  if (Serial1_available && serialEvent1 && Serial1_available()) serialEvent1();
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}

HardwareSerialUsart::HardwareSerialUsart(Usart* peripheral_pointer)
{
	usart_peripheral = peripheral_pointer;
}

void HardwareSerialUsart::tx_empty_callback(void)
{
	//Generated by UART_IER_TXEMPTY
	// If interrupts are enabled, there must be more data in the output
	// buffer. Send the next byte
	
	if(tx_buffer_size == 0)
	{
		//nothing in buffer, disable the interrupt
		usart_disable_interrupt(usart_peripheral, US_IER_TXRDY);
	}
	else
	{
		uint8_t data;
		tx_buffer_remove(&data);
		usart_write(usart_peripheral, data);
	}
}

void HardwareSerialUsart::rx_ready_callback(void)
{
	//Generated by UART_IER_RXRDY
	//This callback happens when a hardware interrupt on the UART has happened
	uint32_t readData;
	usart_read(usart_peripheral, &readData);
	
	rx_buffer_append(readData);
	
	/*
	*rx_buffer_tail = readData & 0xff;

	//increment rx_buffer_tail pointer because we have just added a byte
	if(rx_buffer_tail == rx_buffer_end)
	{
		rx_buffer_tail = rx_buffer;
	}
	else
	{
		rx_buffer_tail++;
	}

	rx_buffer_size++;
	*/
}


// Public Methods //////////////////////////////////////////////////////////////
//TODO: make the config byte from Arduino work with ASF
void HardwareSerialUsart::begin(unsigned long baud)
{ 
	begin(baud, SERIAL_8N1);
}

void HardwareSerialUsart::begin(unsigned long baud, byte config)
{
	IRQn_Type usart_irq_num;
	int usart_id;
	//setup the UART peripheral
	if(usart_peripheral == USART0)
	{
		//set pins for uart0 peripheral, peripheral A RXD = PA9, TXD = PA10
		pio_configure(PIOA, PIO_PERIPH_A, (PIO_PA5A_RXD0 | PIO_PA6A_TXD0), PIO_DEFAULT);
		//set the uart irq number
		usart_irq_num = USART0_IRQn;
		usart_id = ID_USART0;
	}
	else if(usart_peripheral == USART1)
	{
		//set pins for uart1 peripheral, peripheral A RXD = PA21, TXD = PA22
		pio_configure(PIOA, PIO_PERIPH_A, (PIO_PA21A_RXD1 | PIO_PA22A_TXD1), PIO_DEFAULT);
		
		//PIOA->PIO_PDR = ((1 << 21) | (1 << 22));  //disable pio from controlling txd and rxd pins
		//PIOA->PIO_ABCDSR[0] &= ~((1 << 21) | (1 << 22));  //set to peripheral A control
		//PIOA->PIO_ABCDSR[1] &= ~((1 << 21) | (1 << 22));  //set to peripheral A control
		
		usart_irq_num = USART1_IRQn;
		usart_id = ID_USART1;
	}
	else
	{
		return; //error, uart_peripheral not set to correct base address
	}
	
	//setup the buffers
	rx_buffer_size = 0;
	rx_buffer_head = rx_buffer;
	rx_buffer_tail = rx_buffer;
	rx_buffer_end = &rx_buffer[SERIAL_USART_RX_BUFFER_SIZE-1];

	tx_buffer_size = 0;
	tx_buffer_head = tx_buffer;
	tx_buffer_tail = tx_buffer;
	tx_buffer_end = &tx_buffer[SERIAL_USART_RX_BUFFER_SIZE-1];
	
	//setup the options for the uart
	sam_usart_opt_t usart_settings =
	{
		baud,
		US_MR_CHRL_8_BIT,
		US_MR_PAR_NO,
		US_MR_NBSTOP_1_BIT,
		US_MR_CHMODE_NORMAL
	};

	//enable clock gate to usart
	sysclk_enable_peripheral_clock(usart_id);

	//init the uart peripheral
	usart_init_rs232(usart_peripheral, &usart_settings, sysclk_get_peripheral_hz());

	//enable tx and rx
	usart_enable_tx(usart_peripheral);
	usart_enable_rx(usart_peripheral);

	//enable the rx interrupt
	usart_enable_interrupt(usart_peripheral, US_IER_RXRDY);
	NVIC_EnableIRQ(usart_irq_num);
	
	return;
}

void HardwareSerialUsart::end()
{
  // wait for transmission of outgoing data
  flush();
}

int HardwareSerialUsart::available(void)
{
  return rx_buffer_size;
}

int HardwareSerialUsart::peek(void)
{
	if (rx_buffer_size == 0) 
	{
		return -1;
	} 
	else 
	{
		return (*rx_buffer_head);
	}
}

int HardwareSerialUsart::read(void)
{
	if(rx_buffer_size > 0)
	{
		uint8_t data = 0;
		rx_buffer_remove(&data);
		return data;
	}
	else
	{
		return -1;
	}
}

int HardwareSerialUsart::availableForWrite(void)
{
	return (SERIAL_USART_RX_BUFFER_SIZE - tx_buffer_size);
}

void HardwareSerialUsart::flush()
{
	//tx_buffer_size = 0;
	while(tx_buffer_size > 0); //wait for tx to flush
	tx_buffer_head = tx_buffer;
	tx_buffer_tail = tx_buffer;
	
	rx_buffer_head = rx_buffer;
	rx_buffer_tail = rx_buffer;
	cpu_irq_disable();
	rx_buffer_size = 0; //flush rx buffer by dropping everything in buffer
	cpu_irq_enable();
	
}

size_t HardwareSerialUsart::write(uint8_t data)
{
	//if there is no data in buffer and tx is ready just pass to peripheral
	//this is just optimization to avoid buffering and interrupt sending
	if(tx_buffer_size == 0 && usart_peripheral->US_CSR & US_CSR_TXRDY)
	{
		usart_write(usart_peripheral, data);
		return 1;
	}
	else
	{
		while(tx_buffer_size == SERIAL_USART_RX_BUFFER_SIZE) ; //wait for room to put stuff into tx buffer
		tx_buffer_append(data);
		usart_enable_interrupt(usart_peripheral, US_IER_TXRDY);
		return 1;
	}
}

uint8_t HardwareSerialUsart::rx_buffer_append(uint8_t data)
{
	if(rx_buffer_size < SERIAL_USART_RX_BUFFER_SIZE)
	{
		*rx_buffer_tail = data;
		
		if(rx_buffer_tail == rx_buffer_end)
		{
			rx_buffer_tail = rx_buffer;
		}
		else
		{
			rx_buffer_tail++;
		}
		cpu_irq_disable();
		rx_buffer_size++;
		cpu_irq_enable();
		return 1;
	}
	else
	{
		//else no room
		return 0;
	}
}
uint8_t HardwareSerialUsart::rx_buffer_remove(uint8_t* data)
{
	if(rx_buffer_size > 0)
	{
		*data = *rx_buffer_head;
		
		if(rx_buffer_head == rx_buffer_end)
		{
			rx_buffer_head = rx_buffer;
		}
		else
		{
			rx_buffer_head++;
		}
		cpu_irq_disable();
		rx_buffer_size--;
		cpu_irq_enable();
		return 1;
	}
	else
	{
		//nothing to remove
		return 0;
	}
}

uint8_t HardwareSerialUsart::tx_buffer_append(uint8_t data)
{
	if(tx_buffer_size < SERIAL_USART_RX_BUFFER_SIZE)
	{
		*tx_buffer_tail = data;
		if(tx_buffer_tail == tx_buffer_end)
		{
			tx_buffer_tail = tx_buffer;
		}
		else
		{
			tx_buffer_tail++;
		}
		cpu_irq_disable();
		tx_buffer_size++;
		cpu_irq_enable();
		return 1;
	}
	else
	{
		//else no room
		return 0;
	}
}
uint8_t HardwareSerialUsart::tx_buffer_remove(uint8_t* data)
{
	if(tx_buffer_size > 0)
	{
		*data = *tx_buffer_head;
		
		if(tx_buffer_head == tx_buffer_end)
		{
			tx_buffer_head = tx_buffer;
		}
		else
		{
			tx_buffer_head++;
		}
		cpu_irq_disable();
		tx_buffer_size--;
		cpu_irq_enable();
		return 1;
	}
	else
	{
		//nothing to remove
		return 0;
	}
}

HardwareSerialUsart Serial1 = HardwareSerialUsart(USART0);
HardwareSerialUsart Serial2 = HardwareSerialUsart(USART1);

