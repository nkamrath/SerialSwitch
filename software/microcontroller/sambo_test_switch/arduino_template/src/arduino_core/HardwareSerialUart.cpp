/**
 * \file HardwareSerialUart.cpp
 *
 * \brief UART peripheral library for SAMBO platforms
 *
 * Copyright (c) 2016 Nate Kamrath. All rights reserved.
 *
 * \sambo_license_start
 *
 * \page "SAMBO License"
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL AUTHORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \sambo_license_stop
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include "Arduino.h"

#include "HardwareSerialUart.h"


// SerialEvent functions are weak, so when the user doesn't define them,
// the linker just sets their address to 0 (which is checked below).
// The Serialx_available is just a wrapper around Serialx.available(),
// but we can refer to it weakly so we don't pull in the entire
// HardwareSerial instance if the user doesn't also refer to it.
#if defined(HAVE_HWSERIAL0)
  void serialEvent() __attribute__((weak));
  bool Serial0_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL1)
  void serialEvent1() __attribute__((weak));
  bool Serial1_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL2)
  void serialEvent2() __attribute__((weak));
  bool Serial2_available() __attribute__((weak));
#endif

#if defined(HAVE_HWSERIAL3)
  void serialEvent3() __attribute__((weak));
  bool Serial3_available() __attribute__((weak));
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
#endif
#if defined(HAVE_HWSERIAL1)
  if (Serial1_available && serialEvent1 && Serial1_available()) serialEvent1();
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}

HardwareSerialUart::HardwareSerialUart(Uart* peripheral_pointer)
{
	uart_peripheral = peripheral_pointer;
}

void HardwareSerialUart::tx_empty_callback(void)
{
	//Generated by UART_IER_TXEMPTY
	// If interrupts are enabled, there must be more data in the output
	// buffer. Send the next byte
	
	if(tx_buffer_size == 0)
	{
		//nothing in buffer, disable the interrupt
		uart_disable_interrupt(uart_peripheral, UART_IDR_TXEMPTY);
		return;
	}

	uint8_t data = *tx_buffer_head;
	//increment the tx_buffer_head pointer
	if(tx_buffer_head == tx_buffer_end)
	{
		tx_buffer_head = tx_buffer;
	}
	else
	{
		tx_buffer_head++;
	}
	//decrement the buffer counter because we have removed a byte
	tx_buffer_size--;

	//might need to clear the tx empty interrupt?
	uart_write(uart_peripheral, data);
}

void HardwareSerialUart::rx_ready_callback(void)
{
	//Generated by UART_IER_RXRDY
	//This callback happens when a hardware interrupt on the UART has happened
	uart_read(uart_peripheral, rx_buffer_tail);
	
	//increment rx_buffer_tail pointer because we have just added a byte
	if(rx_buffer_tail == rx_buffer_end)
	{
		rx_buffer_tail = rx_buffer;
	}
	else
	{
		rx_buffer_tail++;
	}

	rx_buffer_size++;
}


// Public Methods //////////////////////////////////////////////////////////////
//TODO: make the config byte from Arduino work with ASF
void HardwareSerialUart::begin(unsigned long baud)
{ 
	begin(baud, SERIAL_8N1);
}

void HardwareSerialUart::begin(unsigned long baud, byte config)
{
	IRQn_Type uart_irq_num;
	int uart_id;
	//setup the UART peripheral
	if(uart_peripheral == UART0)
	{
		//set pins for uart0 peripheral, peripheral A RXD = PA9, TXD = PA10
		pio_configure(PIOA, PIO_PERIPH_A, (PIO_PA9A_URXD0 | PIO_PA10A_UTXD0), PIO_DEFAULT);
		//set the uart irq number
		uart_irq_num = UART0_IRQn;
		uart_id = ID_UART0;
	}
	else if(uart_peripheral == UART1)
	{
		//set pins for uart1 peripheral
		uart_irq_num = UART1_IRQn;
		uart_id = ID_UART1;
	}
	else
	{
		return; //error, uart_peripheral not set to correct base address
	}

	//setup the options for the uart
	sam_uart_opt_t uart_settings = 
	{
		sysclk_get_cpu_hz(),
		baud,
		UART_MR_PAR_NO
	};

	//enable clock gate to peripheral
	sysclk_enable_peripheral_clock(uart_id);

	//init the uart peripheral
	uart_init(uart_peripheral, &uart_settings);

	//enable rx tx
	uart_enable_tx(uart_peripheral);
	uart_enable_rx(uart_peripheral);

	//enable the rx interrupt
	uart_enable_interrupt(uart_peripheral, UART_IER_RXRDY);
	NVIC_EnableIRQ(uart_irq_num);

	//setup the buffers
	rx_buffer_size = 0;
	rx_buffer_head = rx_buffer;
	rx_buffer_tail = rx_buffer;
	rx_buffer_end = &rx_buffer[SERIAL_RX_BUFFER_SIZE-1];

	tx_buffer_size = 0;
	tx_buffer_head = tx_buffer;
	tx_buffer_tail = tx_buffer;
	tx_buffer_end = &tx_buffer[SERIAL_TX_BUFFER_SIZE-1];
	return;
}

void HardwareSerialUart::end()
{
  // wait for transmission of outgoing data
  flush();
}

int HardwareSerialUart::available(void)
{
  return rx_buffer_size;
}

int HardwareSerialUart::peek(void)
{
	if (rx_buffer_size == 0) 
	{
		return -1;
	} 
	else 
	{
		return (*rx_buffer_head);
	}
}

int HardwareSerialUart::read(void)
{
	uint8_t data = 0;
	rx_buffer_remove(&data);
	return data;
}

int HardwareSerialUart::availableForWrite(void)
{
	return (SERIAL_TX_BUFFER_SIZE - tx_buffer_size);
}

void HardwareSerialUart::flush()
{
}

size_t HardwareSerialUart::write(uint8_t data)
{
	//if there is no data in buffer and tx is ready just pass to peripheral
	//this is just optimization to avoid buffering and interrupt sending
	if(tx_buffer_size == 0 && uart_peripheral->UART_SR & UART_SR_TXRDY)
	{
		uart_write(uart_peripheral, data);
		return 1;
	}
	else
	{
		uart_enable_interrupt(uart_peripheral, UART_IER_TXEMPTY);
		return tx_buffer_append(data);
	}
}

uint8_t HardwareSerialUart::rx_buffer_append(uint8_t data)
{
	if(rx_buffer_size < SERIAL_RX_BUFFER_SIZE)
	{
		*rx_buffer_tail = data;
		
		if(rx_buffer_head == rx_buffer_end)
		{
			rx_buffer_head = rx_buffer;
		}
		else
		{
			rx_buffer_head++;
		}
		
		rx_buffer_size++;
		return 1;
	}
	else
	{
		//else no room
		return 0;
	}
}
uint8_t HardwareSerialUart::rx_buffer_remove(uint8_t* data)
{
	if(rx_buffer_size > 0)
	{
		*data = *rx_buffer_head;
		
		if(rx_buffer_head == rx_buffer_end)
		{
			rx_buffer_head = rx_buffer;
		}
		else
		{
			rx_buffer_head++;
		}
		
		rx_buffer_size--;
		return 1;
	}
	else
	{
		//nothing to remove
		return 0;
	}
}

uint8_t HardwareSerialUart::tx_buffer_append(uint8_t data)
{
	if(tx_buffer_size < SERIAL_TX_BUFFER_SIZE)
	{
		*tx_buffer_tail = data;
		
		if(tx_buffer_head == tx_buffer_end)
		{
			tx_buffer_head = tx_buffer;
		}
		else
		{
			tx_buffer_head++;
		}
		
		tx_buffer_size++;
		return 1;
	}
	else
	{
		//else no room
		return 0;
	}
}
uint8_t HardwareSerialUart::tx_buffer_remove(uint8_t* data)
{
	if(tx_buffer_size > 0)
	{
		*data = *tx_buffer_head;
		
		if(tx_buffer_head == tx_buffer_end)
		{
			tx_buffer_head = tx_buffer;
		}
		else
		{
			tx_buffer_head++;
		}
		
		tx_buffer_size--;
		return 1;
	}
	else
	{
		//nothing to remove
		return 0;
	}
}

HardwareSerialUart Serial3 = HardwareSerialUart(UART0);
HardwareSerialUart Serial4 = HardwareSerialUart(UART1);

